# Minimum Multiplications to reach End

# Optimal Solution (using Dijkstra's Algorithm)

from typing import List
from collections import deque
 
class Solution:
    
    def minimumMultiplications(self, arr : List[int], start : int, end : int) -> int:
        # code here
        if start == end:
            return 0
        # Create a queue for storing the numbers as a result of multiplication
        # of the numbers in the array and the start number.
        q = deque([(start, 0)])
        
        # Create a dist array to store the number of multiplications to reach
        # a particular number from the start number.
        dist = [float('inf')] * 100000
        dist[start] = 0
        mod = 100000

        # Multiply the start number with each of the numbers in the array
        # until we get the end number.
        while q:
            node, steps = q.popleft()

            for it in arr:
                num = (it * node) % mod

                # If the number of multiplications is less than before
                # in order to reach a number, we update the dist array.
                if steps + 1 < dist[num]:
                    dist[num] = steps + 1

                    # Whenever we reach the end number
                    # return the calculated steps
                    if num == end:
                        return steps + 1
                    q.append((num, steps + 1))

        # If the end number is unattainable.
        return -1


# Time Complexity : O(100000 * N) 

# Where ‘100000’ are the total possible numbers generated by multiplication (hypothetical) and N = size of the array with numbers of which each node could be multiplied.

# Space Complexity :  O(100000 * N) 

# Where ‘100000’ are the total possible numbers generated by multiplication (hypothetical) and N = size of the array with numbers of which each node could be multiplied. 100000 * N is the max possible queue size. The space complexity of the dist array is constant.